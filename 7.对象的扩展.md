# 目录
- 属性的简洁表示法
- Object新增的方法

# 1. 属性的简洁表示法

如果属性和属性名相同，则可以写成一个，另外，函数作为属性的时候，可以省略 `function` 关键字，如下所示。

```javascript
let birth = '2000/01/01';
const Person = {
  name: '张三',
  // 等同于 birth: birth
  birth,
  // 等同于 hello: function(){}
  hello () {
    console.log('我的名字叫', this.name);
  }
}
```

# 2. Object新增的方法

## Object.is()
比较两个值是否相等。ES5 中有两个运算符 `==` 和 `===`。但是他们呢都有缺点，前者会自动转换数据类型，后者的 `NaN` 不等于自身，以及 `-0` 等于 `+0`。
ES6 中用来严格表两个值是否相等，与 `===` 基本一致。

```javascript
Object.is({}, {}); // false
Object.is(NaN, NaN); // true
Object.is(+0, -0); // false
```
## Object.assign()

### 基本用法

`Object.assign` 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

```javascript
const target = { a: 1, b: 1 };

const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
```
`Object.assign` 方法的第一个参数是目标对象，后面的参数都是源对象。注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

### 参数不是对象的处理

如果该参数不是对象，则会先转成对象，然后返回。如果无法转成对象，则会报错，比如 `undefined` 和 `null`

```javascript
typeof Object.assign(2) // "object"
Object.assign('abc'); // {0: 'a', 1: 'b', 2: 'c'}
Object.assign(undefined) // 报错
Object.assign(null) // 报错
```
### 浅拷贝

`Object.assign` 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。
```javascript
const obj1 = {a: {b: 1}};
const obj2 = Object.assign({}, obj1);
obj1.a.b = 2;
obj2.a.b // 2
```
上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。


