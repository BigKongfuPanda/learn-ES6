# 目录

- 简介
- Object.getPropertyOf()
- super 关键字
- 类的 protoype 和 __proto__ 属性
- 原生构造函数的继承
- Mixin 模式的实现

# 1、简介

class 可以通过 `extends` 关键字实现继承。

**在子类继承父类的时候，在 `constructor` 中必须首先调用 `super()` 方法，然后才能使用 `this` 。**

```js
// 父类
class Point {
  constructor (x){
    this.x = x;
  }
  toString(){
    console.log('这种颜色耐脏!');
  }
}

// 子类
class ColorPoint extends Point {
  constructor(x, color){
    // 必须首先调用父类的constructor(x)
    super(x);
    this.color = color;
  }
  toString(){
    // 调用父类的toString()
    return this.color + ' ' + super.toString();
  }
}
```

子类必须在 `constructor` 方法中调用 `super` 方法，否则新建实例时会报错。这是因为子类自己的 `this` 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 `super` 方法，子类就得不到 `this` 对象。

ES5 的继承，实质是先创造子类的实例对象 `this` ，然后再将父类的方法添加到 `this` 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象 `this` （所以必须先调用 `super` 方法），然后再用子类的构造函数修改 `this` 。

父类的静态方法，也会被子类继承。

```js
class A {
  static hello(){
    console.log('hello world');
  }
}

class B extends A {

}

B.hello() // hello world
```

上面代码中，`hello()` 是 `A` 类的静态方法， `B` 继承 `A` ，也继承了 `A` 的静态方法。