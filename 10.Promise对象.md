# 目录

- Promise 的含义
- 基本用法
- 常用方法
- 应用

# 1. Promise 的含义

`Promise` 是异步编程的一种解决方案，避免了传统的回调函数的层层嵌套，也就是常说的“回调地狱”。

`Promise` 一旦新建就会立即执行，无法中途取消。

# 2. 基本用法

ES6 规定，`Promise` 对象是一个构造函数，用来生成 `Promise` 实例。

```js
const promise = new Promise (function (resolve, reject) {
  if (/* 异步操作成功*/) {
    resolve(value);
  } else {
    /* 操作失败 */
    reject(error);
  }
});
```

`Promise` 实例生成以后，可以用 `then` 方法分别指定 `resolved` 状态和 `rejected` 状态的回调函数。

```js
promise.then(function(value) {
  // success
}, function (error) {
  // failure
});
```

`Promise` 新建后就会立即执行

```js
let promise = new Promise(function (resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function(){
  console.log('resolved');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
```

上面代码中，`Promise` 新建后立即执行，所以首先输出的是`Promise`。然后，`then` 方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以 `resolved` 最后输出。

## 实例：异步加载图片

```js
function loadImageAsync (url) {
  return new Promise(function(resolve, reject) {
    const image = new Image();

    image.onload = function () {
      resolve(image);
    };

    image.onerror = function () {
      reject(new Error('Could not load image at ' + url));
    }

    image.src = url;
  });
}
```

## 实例：封装 Ajax

```js
const getJSON = function (url) {
  const promise = new Promise(function(resolve, reject){
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onreadystatechange = handler;
    xhr.responseType = 'json';
    xhr.setRequestHeader('Accept', 'application/json');
    xhr.send();

    const handler = function () {
      if (this.readyState !== 4) {
        return ;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
  });

  return promise;
};

getJSON('/nameList.json').then(function (json) {
  console.log('contents' + json);
}, function (error) {
  console.error('出错了', error);
});
```

一般来说，调用 `resolve` 或 `reject` 以后，`Promise` 的使命就完成了，后继操作应该放到 `then` 方法里面，而不应该直接写在 `resolve` 或 `reject` 的后面。所以，最好在它们前面加上 `return` 语句，这样就不会有意外。

```js
new Promise((resolve, reject) => {
  resolve(1);
  console.log(2); //虽然此句会执行，但是不建议这样做
}).then(r => {
  console.log(r);
});
// 2
// 1

// resolve 前加 return
new Promise((resolve, reject) => {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
```

一般来说，不要在 `then` 方法里面定义 `Reject` 状态的回调函数（即 `then` 的第二个参数），总是使用 `catch` 方法。

```js
// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });

// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });
```